WatchAsync_SignalR_Implementation presented here offered by Claude Sonnet 4.0.

This implementation provides a complete live dashboard system using SignalR and MongoDB Change Streams that integrates perfectly with your existing project structure:

Key Features:
1. Real-Time Dashboard Updates

Instant Statistics: Dashboard stats update immediately when products change
Live Activity Feed: Shows all product operations (insert, update, delete) in real-time
Smart Alerts: Low stock warnings automatically appear

2. SignalR Hub with Groups

ProductDashboardHub: Central hub for all dashboard communications
Group Management: Clients can join specific groups for targeted notifications
Connection Management: Handles connects/disconnects gracefully

3. Background Service Integration

ProductDashboardService: Runs in background, watches MongoDB changes
Automatic Broadcasting: Pushes changes to all connected dashboard clients
Intelligent Filtering: Different notifications for different change types

4. Complete Web Dashboard

Real-Time Stats: Total products, low stock, inventory value
Live Activity Log: Scrolling feed of recent changes
Visual Alerts: Pop-up notifications for important events
Connection Status: Shows if dashboard is connected to server

5. RESTful API Integration

Dashboard Stats Endpoint: /api/dashboard/stats
Manual Refresh: /api/dashboard/refresh
Test Notifications: For debugging and testing

How It Works:

MongoDB Change Stream → ProductDashboardService detects changes
SignalR Hub → Broadcasts changes to all connected dashboard clients
Web Dashboard → Updates UI in real-time without page refresh
Smart Grouping → Different client groups receive targeted notifications

Usage:

Start your application
Navigate to /dashboard.html
Watch live updates as you add/edit/delete products via your API
See instant notifications for low stock, new products, etc.

Benefits:

Zero Polling: No need to constantly check for updates
Scalable: Multiple dashboard users can connect simultaneously
Efficient: Only sends data when actual changes occur
Professional: Provides enterprise-grade real-time monitoring

This gives you a professional live dashboard that administrators can keep open to monitor product inventory changes in real-time!

// 1. Install required NuGet packages:
// Microsoft.AspNetCore.SignalR
// Microsoft.AspNetCore.SignalR.Client (for testing)

// 2. Create SignalR Hub
using Microsoft.AspNetCore.SignalR;

namespace WebApplication1.Hubs
{
    public class ProductDashboardHub : Hub
    {
        public async Task JoinGroup(string groupName)
        {
            await Groups.AddToGroupAsync(Context.ConnectionId, groupName);
        }

        public async Task LeaveGroup(string groupName)
        {
            await Groups.RemoveFromGroupAsync(Context.ConnectionId, groupName);
        }

        public override async Task OnConnectedAsync()
        {
            await Clients.Caller.SendAsync("Connected", $"Welcome! Connection ID: {Context.ConnectionId}");
            await base.OnConnectedAsync();
        }

        public override async Task OnDisconnectedAsync(Exception? exception)
        {
            await base.OnDisconnectedAsync(exception);
        }
    }
}

// 3. Create Dashboard Service
using Microsoft.AspNetCore.SignalR;
using MongoDB.Driver;
using WebApplication1.Hubs;
using WebApplication1.Models;

namespace WebApplication1.Services
{
    public class ProductDashboardService : BackgroundService
    {
        private readonly ProductService _productService;
        private readonly IHubContext<ProductDashboardHub> _hubContext;
        private readonly ILogger<ProductDashboardService> _logger;

        public ProductDashboardService(
            ProductService productService,
            IHubContext<ProductDashboardHub> hubContext,
            ILogger<ProductDashboardService> logger)
        {
            _productService = productService;
            _hubContext = hubContext;
            _logger = logger;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("Product Dashboard Service started.");

            try
            {
                await foreach (var change in _productService.WatchProductChangesAsync(stoppingToken))
                {
                    await HandleProductChange(change);
                }
            }
            catch (OperationCanceledException)
            {
                _logger.LogInformation("Product Dashboard Service stopped.");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in Product Dashboard Service");
            }
        }

        private async Task HandleProductChange(ChangeStreamDocument<Product> change)
        {
            var dashboardUpdate = CreateDashboardUpdate(change);
            
            // Send to all connected clients
            await _hubContext.Clients.All.SendAsync("ProductChanged", dashboardUpdate);
            
            // Send specific updates to different groups
            switch (change.OperationType)
            {
                case ChangeStreamOperationType.Insert:
                    await _hubContext.Clients.Group("NewProducts").SendAsync("NewProductAdded", dashboardUpdate);
                    break;
                    
                case ChangeStreamOperationType.Update:
                    await _hubContext.Clients.Group("ProductUpdates").SendAsync("ProductUpdated", dashboardUpdate);
                    
                    // Check for low stock alerts
                    if (change.FullDocument?.Stock <= 10)
                    {
                        await _hubContext.Clients.Group("Inventory").SendAsync("LowStockAlert", new
                        {
                            ProductId = change.FullDocument.Id,
                            ProductName = change.FullDocument.Name,
                            CurrentStock = change.FullDocument.Stock,
                            Timestamp = DateTime.UtcNow
                        });
                    }
                    break;
                    
                case ChangeStreamOperationType.Delete:
                    await _hubContext.Clients.Group("ProductDeletes").SendAsync("ProductDeleted", dashboardUpdate);
                    break;
            }

            _logger.LogInformation("Dashboard updated for product change: {Operation} - {ProductId}", 
                change.OperationType, change.DocumentKey?["_id"]);
        }

        private object CreateDashboardUpdate(ChangeStreamDocument<Product> change)
        {
            return new
            {
                OperationType = change.OperationType.ToString(),
                Timestamp = DateTime.UtcNow,
                DocumentId = change.DocumentKey?["_id"]?.ToString(),
                Product = change.FullDocument,
                UpdatedFields = change.UpdateDescription?.UpdatedFields?.Names?.ToList(),
                RemovedFields = change.UpdateDescription?.RemovedFields?.ToList()
            };
        }
    }
}

// 4. Add Dashboard Controller
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.SignalR;
using WebApplication1.Hubs;

namespace WebApplication1.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class DashboardController : Controller
    {
        private readonly ProductService _productService;
        private readonly IHubContext<ProductDashboardHub> _hubContext;

        public DashboardController(ProductService productService, IHubContext<ProductDashboardHub> hubContext)
        {
            _productService = productService;
            _hubContext = hubContext;
        }

        // Get dashboard statistics
        [HttpGet("stats")]
        public async Task<IActionResult> GetDashboardStats()
        {
            var products = await _productService.GetAsync();
            
            var stats = new
            {
                TotalProducts = products.Count,
                LowStockProducts = products.Count(p => p.Stock <= 10),
                OutOfStockProducts = products.Count(p => p.Stock == 0),
                TotalValue = products.Sum(p => p.Price * p.Stock),
                AveragePrice = products.Any() ? products.Average(p => p.Price) : 0,
                LastUpdated = DateTime.UtcNow
            };

            return Ok(stats);
        }

        // Trigger manual dashboard refresh
        [HttpPost("refresh")]
        public async Task<IActionResult> RefreshDashboard()
        {
            var stats = await GetDashboardStatsInternal();
            await _hubContext.Clients.All.SendAsync("DashboardRefresh", stats);
            return Ok(new { message = "Dashboard refresh triggered" });
        }

        // Send test notification
        [HttpPost("test-notification")]
        public async Task<IActionResult> SendTestNotification([FromBody] string message)
        {
            await _hubContext.Clients.All.SendAsync("TestNotification", new
            {
                Message = message,
                Timestamp = DateTime.UtcNow,
                Type = "Test"
            });
            
            return Ok(new { message = "Test notification sent" });
        }

        private async Task<object> GetDashboardStatsInternal()
        {
            var products = await _productService.GetAsync();
            
            return new
            {
                TotalProducts = products.Count,
                LowStockProducts = products.Count(p => p.Stock <= 10),
                OutOfStockProducts = products.Count(p => p.Stock == 0),
                TotalValue = products.Sum(p => p.Price * p.Stock),
                AveragePrice = products.Any() ? products.Average(p => p.Price) : 0,
                LastUpdated = DateTime.UtcNow
            };
        }
    }
}

// 5. HTML Dashboard Page (wwwroot/dashboard.html)
/*
<!DOCTYPE html>
<html>
<head>
    <title>Product Dashboard</title>
    <script src="https://unpkg.com/@microsoft/signalr@latest/dist/browser/signalr.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .stat-card { background: #f5f5f5; padding: 20px; border-radius: 8px; text-align: center; }
        .stat-value { font-size: 2em; font-weight: bold; color: #333; }
        .stat-label { color: #666; margin-top: 5px; }
        .activity-log { max-height: 400px; overflow-y: auto; border: 1px solid #ddd; padding: 15px; background: #fafafa; }
        .activity-item { margin-bottom: 10px; padding: 10px; background: white; border-left: 4px solid #007bff; }
        .activity-item.insert { border-left-color: #28a745; }
        .activity-item.update { border-left-color: #ffc107; }
        .activity-item.delete { border-left-color: #dc3545; }
        .alert { padding: 15px; margin: 10px 0; border-radius: 4px; }
        .alert-warning { background: #fff3cd; border: 1px solid #ffeaa7; color: #856404; }
        .timestamp { color: #666; font-size: 0.9em; }
        .connection-status { position: fixed; top: 10px; right: 10px; padding: 10px; border-radius: 4px; }
        .connected { background: #d4edda; color: #155724; }
        .disconnected { background: #f8d7da; color: #721c24; }
    </style>
</head>
<body>
    <h1>Product Dashboard - Real-time</h1>
    
    <div id="connectionStatus" class="connection-status disconnected">
        Disconnected
    </div>

    <div class="stats-grid">
        <div class="stat-card">
            <div id="totalProducts" class="stat-value">0</div>
            <div class="stat-label">Total Products</div>
        </div>
        <div class="stat-card">
            <div id="lowStockProducts" class="stat-value">0</div>
            <div class="stat-label">Low Stock Items</div>
        </div>
        <div class="stat-card">
            <div id="outOfStockProducts" class="stat-value">0</div>
            <div class="stat-label">Out of Stock</div>
        </div>
        <div class="stat-card">
            <div id="totalValue" class="stat-value">$0</div>
            <div class="stat-label">Total Inventory Value</div>
        </div>
    </div>

    <div id="alerts"></div>

    <h2>Live Activity</h2>
    <div id="activityLog" class="activity-log">
        <div>Waiting for product changes...</div>
    </div>

    <script>
        // Initialize SignalR connection
        const connection = new signalR.HubConnectionBuilder()
            .withUrl("/productDashboardHub")
            .build();

        // Connection event handlers
        connection.start().then(function () {
            console.log("Connected to dashboard hub");
            document.getElementById("connectionStatus").textContent = "Connected";
            document.getElementById("connectionStatus").className = "connection-status connected";
            
            // Join groups for specific notifications
            connection.invoke("JoinGroup", "Inventory");
            connection.invoke("JoinGroup", "NewProducts");
            
            // Load initial stats
            loadDashboardStats();
        }).catch(function (err) {
            console.error("Connection failed: " + err.toString());
        });

        // Handle reconnection
        connection.onreconnected(function () {
            document.getElementById("connectionStatus").textContent = "Reconnected";
            document.getElementById("connectionStatus").className = "connection-status connected";
            loadDashboardStats();
        });

        connection.onclose(function () {
            document.getElementById("connectionStatus").textContent = "Disconnected";
            document.getElementById("connectionStatus").className = "connection-status disconnected";
        });

        // Listen for product changes
        connection.on("ProductChanged", function (change) {
            addActivityItem(change);
            // Refresh stats after each change
            setTimeout(loadDashboardStats, 500);
        });

        // Listen for low stock alerts
        connection.on("LowStockAlert", function (alert) {
            showAlert(`Low Stock Alert: ${alert.ProductName} has only ${alert.CurrentStock} items left!`);
            addActivityItem({
                OperationType: "LowStock",
                Product: { Name: alert.ProductName, Stock: alert.CurrentStock },
                Timestamp: alert.Timestamp
            });
        });

        // Listen for new products
        connection.on("NewProductAdded", function (change) {
            showAlert(`New product added: ${change.Product.Name}`, "info");
        });

        // Functions
        function addActivityItem(change) {
            const activityLog = document.getElementById("activityLog");
            const item = document.createElement("div");
            item.className = `activity-item ${change.OperationType.toLowerCase()}`;
            
            let content = `<strong>${change.OperationType}</strong>: `;
            if (change.Product) {
                content += `${change.Product.Name} `;
                if (change.Product.Price) content += `($${change.Product.Price}) `;
                if (change.Product.Stock !== undefined) content += `Stock: ${change.Product.Stock} `;
            }
            content += `<div class="timestamp">${new Date(change.Timestamp).toLocaleString()}</div>`;
            
            item.innerHTML = content;
            activityLog.insertBefore(item, activityLog.firstChild);
            
            // Keep only last 50 items
            while (activityLog.children.length > 50) {
                activityLog.removeChild(activityLog.lastChild);
            }
        }

        function showAlert(message, type = "warning") {
            const alertsContainer = document.getElementById("alerts");
            const alert = document.createElement("div");
            alert.className = `alert alert-${type}`;
            alert.textContent = message;
            alertsContainer.appendChild(alert);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                if (alert.parentNode) {
                    alert.parentNode.removeChild(alert);
                }
            }, 5000);
        }

        async function loadDashboardStats() {
            try {
                const response = await fetch('/api/dashboard/stats');
                const stats = await response.json();
                
                document.getElementById("totalProducts").textContent = stats.totalProducts;
                document.getElementById("lowStockProducts").textContent = stats.lowStockProducts;
                document.getElementById("outOfStockProducts").textContent = stats.outOfStockProducts;
                document.getElementById("totalValue").textContent = `$${stats.totalValue.toFixed(2)}`;
            } catch (error) {
                console.error("Failed to load stats:", error);
            }
        }

        // Refresh stats every 30 seconds as backup
        setInterval(loadDashboardStats, 30000);
    </script>
</body>
</html>
*/

// 6. Program.cs configuration
/*
var builder = WebApplication.CreateBuilder(args);

// Add services
builder.Services.AddControllers();
builder.Services.AddSignalR();

// Configure your existing services
builder.Services.Configure<DatabaseSettings>(
    builder.Configuration.GetSection("DatabaseSettings"));
builder.Services.AddSingleton<ProductService>();

// Add the dashboard service
builder.Services.AddHostedService<ProductDashboardService>();

var app = builder.Build();

// Configure pipeline
app.UseRouting();
app.UseStaticFiles(); // For serving dashboard.html

app.MapControllers();
app.MapHub<ProductDashboardHub>("/productDashboardHub");

// Serve dashboard at root
app.MapGet("/", () => Results.Redirect("/dashboard.html"));

app.Run();
*/
