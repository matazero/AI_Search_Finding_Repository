Asked to Claude Sonnet 4

Configuration Notes:

MongoDB Replica Set: Change streams require a MongoDB replica set or sharded cluster
Permissions: Ensure your MongoDB user has the necessary permissions to read the oplog
Resource Management: Be mindful of connection limits and memory usage with long-running change streams

The implementation follows your existing project structure and provides both simple and advanced usage patterns for MongoDB change streams.

Question : Ok tell me WatchAsync. Documentation says Watches changes on the collection. What is it used for ? What kind of changes

Answer :

MongoDB's WatchAsync method is used to monitor real-time changes to a collection through Change Streams. It allows your application to react immediately when data changes occur in the database.
What Changes Does It Watch?
The WatchAsync method can monitor these types of operations:
1. Document Operations

Insert: New documents added to the collection
Update: Existing documents modified (field changes, replacements)
Replace: Entire document replaced
Delete: Documents removed from the collection

2. Collection Operations

Drop: Collection is dropped/deleted
Rename: Collection is renamed

3. Database Operations

DropDatabase: Entire database is dropped

4. Index Operations

CreateIndexes: New indexes created
DropIndexes: Indexes removed

Common Use Cases:
-----------------
Here are practical scenarios where WatchAsync is extremely valuable:
1. Real-Time Notifications
csharp// Notify users when new products are added
await foreach (var change in _productService.WatchProductChangesAsync())
{
    if (change.OperationType == ChangeStreamOperationType.Insert)
    {
        await NotifyUsersOfNewProduct(change.FullDocument);
    }
}
2. Cache Invalidation
csharp// Update Redis cache when product prices change
if (change.OperationType == ChangeStreamOperationType.Update)
{
    var updatedFields = change.UpdateDescription?.UpdatedFields;
    if (updatedFields?.ContainsKey("Price") == true)
    {
        await _cache.RemoveAsync($"product:{change.DocumentKey["_id"]}");
    }
}
3. Data Synchronization
csharp// Sync changes to another database or search engine
await foreach (var change in _productService.WatchProductChangesAsync())
{
    await _elasticsearchService.SyncProduct(change);
    await _analyticsService.TrackProductChange(change);
}
4. Audit Logging
csharp// Log all changes for compliance
await foreach (var change in _productService.WatchProductChangesAsync())
{
    await _auditService.LogChange(new AuditEntry
    {
        Operation = change.OperationType.ToString(),
        DocumentId = change.DocumentKey["_id"].ToString(),
        Timestamp = change.ClusterTime.Timestamp,
        UserId = GetCurrentUserId()
    });
}
5. Live Dashboard Updates
csharp// Update dashboards in real-time via SignalR
await foreach (var change in _productService.WatchProductChangesAsync())
{
    await _hubContext.Clients.All.SendAsync("ProductChanged", new
    {
        Operation = change.OperationType.ToString(),
        Product = change.FullDocument
    });
}
6. Workflow Triggers
csharp// Trigger workflows based on data changes
if (change.OperationType == ChangeStreamOperationType.Update)
{
    var product = change.FullDocument;
    if (product.Stock <= product.ReorderLevel)
    {
        await _inventoryService.TriggerReorderProcess(product.Id);
    }
}

What Information Do You Get?
Each change event contains detailed information:
csharpvar changeDocument = new ChangeStreamDocument<Product>
{
    OperationType = ChangeStreamOperationType.Update,
    FullDocument = updatedProduct,           // The complete updated document
    FullDocumentBeforeChange = originalProduct, // Document before the change
    DocumentKey = new BsonDocument("_id", productId),
    UpdateDescription = new ChangeStreamUpdateDescription
    {
        UpdatedFields = new BsonDocument("Price", newPrice),
        RemovedFields = new string[] { "discontinued" }
    },
    ClusterTime = timestamp,
    ResumeToken = resumeToken    // For resuming the stream
};
Key Benefits

Real-Time: Changes are detected immediately, not through polling
Efficient: Uses MongoDB's oplog, minimal overhead
Reliable: Can resume from where it left off using resume tokens
Flexible: Can filter specific operations or fields
Scalable: Works across replica sets and sharded clusters

Important Requirements

MongoDB 3.6+: Change streams require MongoDB 3.6 or later
Replica Set: Must be running on a replica set or sharded cluster (not standalone)
Permissions: User needs read access to the collection and oplog

Change Streams essentially turn MongoDB into a reactive database, allowing your applications to respond to data changes in real-time rather than having to constantly poll for updates.
